% catgen.pl
% Categories generated by graphs, at both ends
% of the preorder--free category spectrum
% discussed in Fong & Spivak ¬ß3.2.3.

:- use_module(library(lists)).
:- use_module(library(clpz)).
:- use_module(library(dif)).
:- use_module(library(reif)).
:- use_module(library(lambda)).
:- use_module(library(si)).

%% :- module(catgen, [
%% 	      simplex/2,
%%               %three/1, three/2, three/3,
%%               dagr_freecat_nsteps_arrow/5,
%%               dagr_freecat_minarrow/4,
%%               dagr_po_t/4,
%%               dagr_po/3
%% 	  ]).

:- use_module(library(dcgs)).
:- use_module(library(time)).
:- use_module(library(debug)).
:- use_module(library(error)).

clpz:monotonic.

% Wait!  I now see the underlying formalities much more clearly.
% I need *both* ends of the 'preorder--free category spectrum'
% discussed in Fong & Spivak ¬ß3.2.3.
% For reasons of efficiency, I will provide the generating graphs
% containing what Riehl (Ex 4.1.3, p120) calls *atomic arrows* in
% the form of [predicates that define] Directed Acyclic Graphs (DAGs),
% but with allowances made for some reflexive arrows already to be
% present in the DAG.  I will call such things 'DAGR's.
% A reason for this 'allowance' is that the CLP(Z) constraints I'll
% use to define the atomic arrows in this application will most often
% (in their simplest forms) be stated with *non-strict* inequalities,
% and thus will 'naturally' include the case of equality.  To allow
% such freedom of expression in the problem domain, I will require
% my transitive-closure predicates to do any necessary dif/2 checks.
% TODO: Find out if there is a proper, formal name for 'DAGR's!

% One appealing notation might be dagr_freecat/2 with args (G, Arrow),
% the arrow being a list [Xn,...,X0] with G(Xi,Xi-1) for i in 1..n.
% This even upholds the primacy of arrows (morphisms) in Cat Theory!
% But the notation C(_,_) suggests a dagr_freecat_arrow/4 with args
% (G, A,B, Arrow) such that invoking,
% dagr_freecat_arrow(G, A, B, P) would yield all paths P from A to B.
% Fair enumeration of the paths A->B is needed for efficient experimental
% searches.  So I'll need to implement all these predicates using
% 'internal' auxiliaries that carry along a max-steps argument.
% A further improvement might simply find the minimum-length arrows;
% this might be called dagr_freecat_minarrow/4.

% It would be nice to fairly enumerate all connected graph nodes
% without duplication.  Perhaps this generally requires a dedicated
% predicate that *states what holds* regarding which nodes _exist_.
% Surely, /checking/ for duplication would increase computational
% complexity in a way that will be generally undesirable.
% Indeed, the way categories are defined -- with *both* OBJECT and
% ARROW functions -- suggests that this may be an inherent aspect
% of categorical constructions.

% This is however not quite sufficient.  I do need fair enumeration
% of *pairs* of graph nodes too.  One way to get at this would be
% to require that a version of the arity-1 graph predicate be written
% that takes (A-B) variable pairs.

% But I would rather avoid imposing additional burdens on client code.
% It might be better to implement the 2-dimensional enumeration upon
% one enumerative-slice predicate required of the client code.
% How should this predicate be distinguished?  Might I use lambdas
% for this?  That is, should the arity-1 predicate take a *lambda*?

% Here is how that might work:
% We use the *free variables* of the lambda to communicate the tuple
% of variables to be instantiated with the fair enumeration.
% The goal contains the 'slice' information as a CLP(Z) goal.
% In theory, anyway!  Let's try putting it into practice...

% To enumerate in higher dimensions, I'll need to construct
% slices from simplexes.
% TODO: Find a better name that does not conflict with library(simplex).
%       Perhaps, if no recognized formal name for this emerges, 'taxi'
%       may suffice, given the 'taxi-cab metric' involved here.
simplex(N, Vs) :-
    #N #>= 0,
    sum(Vs, #=, N),
    maplist(#=<(0), Vs).

%?- simplex(1, [Nx,Ny]).
%@    clpz:(Nx in 0..1), clpz:(#Nx+ #Ny#=1), clpz:(Ny in 0..1).

%?- simplex(0, [Nx,Ny]).
%@    Nx = 0, Ny = 0.

%?- simplex(1, [Nx,Ny]), label([Nx,Ny]).
%@    Nx = 0, Ny = 1
%@ ;  Nx = 1, Ny = 0.

%?- simplex(2, [Nx,Ny,Nz]), label([Nx,Ny,Nz]).
%@    Nx = 0, Ny = 0, Nz = 2
%@ ;  Nx = 0, Ny = 1, Nz = 1
%@ ;  Nx = 0, Ny = 2, Nz = 0
%@ ;  Nx = 1, Ny = 0, Nz = 1
%@ ;  Nx = 1, Ny = 1, Nz = 0
%@ ;  Nx = 2, Ny = 0, Nz = 0.

%?- length(Ns, 3), simplex(2, Ns), label(Ns).
%@    Ns = [0,0,2]
%@ ;  Ns = [0,1,1]
%@ ;  Ns = [0,2,0]
%@ ;  Ns = [1,0,1]
%@ ;  Ns = [1,1,0]
%@ ;  Ns = [2,0,0].

%?- simplex(2, [X,Y,Z]).
%@    clpz:(X in 0..2), clpz:(#X+ #Y+ #Z#=2), clpz:(Y in 0..2), clpz:(Z in 0..2).

% NB: The 'indomain(N)' below is necessary to enforce fairness.
%?- N in 0..2, indomain(N), simplex(N, [X,Y,Z]), label([X,Y,Z]).
%@    N = 0, X = 0, Y = 0, Z = 0
%@ ;  N = 1, X = 0, Y = 0, Z = 1
%@ ;  N = 1, X = 0, Y = 1, Z = 0
%@ ;  N = 1, X = 1, Y = 0, Z = 0
%@ ;  N = 2, X = 0, Y = 0, Z = 2
%@ ;  N = 2, X = 0, Y = 1, Z = 1
%@ ;  N = 2, X = 0, Y = 2, Z = 0
%@ ;  N = 2, X = 1, Y = 0, Z = 1
%@ ;  N = 2, X = 1, Y = 1, Z = 0
%@ ;  N = 2, X = 2, Y = 0, Z = 0.

three(a, b). % Binary relation three/2
three(a, c). % states which
three(b, c). % arrows exist.

% The predicate three/1 by contrast
% fairly enumerates tuples of objects,
% as fixed-length lists.  First, 1-tuples:
three(0 - [a]).
three(1 - [X]) :- member(X,"bc").

% And now K-tuples, for K ‚â• 2:
three(N - Vs) :-
    length(Vs, K), K #> 1,
    same_length(Vs, Ns),
    simplex(N, Ns),
    maplist(\Ni^V^three(Ni - [V]), Ns, Vs),
    label([N|Ns]).

% Finally, three/3 giving an upper bounds on the lengths of
% shortest paths (if they exist!) between given objects.
% This is trivial for the category *three*, but in general
% allows for finite path searches guaranteed to terminate.
three(X, Y, N) :- #L #>= 0, three(L-[X,Y]), N = 2.

%?- three(0 - [X,Y]).
%@    X = a, Y = a
%@ ;  false.

%?- three(1 - [X,Y]).
%@    X = a, Y = b
%@ ;  X = a, Y = c
%@ ;  X = b, Y = a
%@ ;  X = c, Y = a
%@ ;  false.

%?- three(2 - [X,Y]).
%@    X = b, Y = b
%@ ;  X = b, Y = c
%@ ;  X = c, Y = b
%@ ;  X = c, Y = c
%@ ;  false.

%?- three(3 - [X,Y]).
%@    false.

%?- three(N - [X,Y]).
%@    N = 0, X = a, Y = a
%@ ;  N = 1, X = a, Y = b
%@ ;  N = 1, X = a, Y = c
%@ ;  N = 1, X = b, Y = a
%@ ;  N = 2, X = b, Y = b
%@ ;  N = 2, X = b, Y = c
%@ ;  N = 1, X = c, Y = a
%@ ;  N = 2, X = c, Y = b
%@ ;  N = 2, X = c, Y = c
%@ ;  false.

%?- N in 0..2, three(N - [X]).
%@    N = 0, X = a
%@ ;  N = 1, X = b
%@ ;  N = 1, X = c
%@ ;  false.

%?- maplist(\N^V^three(N - [V]), [1,1], [A,B]).
%@    A = b, B = b
%@ ;  A = b, B = c
%@ ;  A = c, B = b
%@ ;  A = c, B = c
%@ ;  false.

%?- three(1 - [P,Q]).
%@    P = a, Q = b
%@ ;  P = a, Q = c
%@ ;  P = b, Q = a
%@ ;  P = c, Q = a
%@ ;  false.

%?- three(0 - [P,Q,R]).
%@    P = a, Q = a, R = a
%@ ;  false.

%?- three(1 - [P,Q,R]).
%@    P = a, Q = a, R = b
%@ ;  P = a, Q = a, R = c
%@ ;  P = a, Q = b, R = a
%@ ;  P = a, Q = c, R = a
%@ ;  P = b, Q = a, R = a
%@ ;  P = c, Q = a, R = a
%@ ;  false.

%?- three(2 - [P,Q,R]).
%@    P = a, Q = b, R = b
%@ ;  P = a, Q = b, R = c
%@ ;  P = a, Q = c, R = b
%@ ;  P = a, Q = c, R = c
%@ ;  P = b, Q = a, R = b
%@ ;  P = b, Q = a, R = c
%@ ;  P = c, Q = a, R = b
%@ ;  P = c, Q = a, R = c
%@ ;  P = b, Q = b, R = a
%@ ;  P = b, Q = c, R = a
%@ ;  P = c, Q = b, R = a
%@ ;  P = c, Q = c, R = a
%@ ;  false.

%?- three(3 - [P,Q,R]).
%@    P = b, Q = b, R = b
%@ ;  P = b, Q = b, R = c
%@ ;  P = b, Q = c, R = b
%@ ;  P = b, Q = c, R = c
%@ ;  P = c, Q = b, R = b
%@ ;  P = c, Q = b, R = c
%@ ;  P = c, Q = c, R = b
%@ ;  P = c, Q = c, R = c
%@ ;  false.

%?- three(4 - [P,Q,R]).
%@    false.

%?- three(4 - [P,Q,R,S]).
%@    P = b, Q = b, R = b, S = b
%@ ;  P = b, Q = b, R = b, S = c
%@ ;  P = b, Q = b, R = c, S = b
%@ ;  P = b, Q = b, R = c, S = c
%@ ;  P = b, Q = c, R = b, S = b
%@ ;  P = b, Q = c, R = b, S = c
%@ ;  P = b, Q = c, R = c, S = b
%@ ;  P = b, Q = c, R = c, S = c
%@ ;  P = c, Q = b, R = b, S = b
%@ ;  P = c, Q = b, R = b, S = c
%@ ;  P = c, Q = b, R = c, S = b
%@ ;  P = c, Q = b, R = c, S = c
%@ ;  P = c, Q = c, R = b, S = b
%@ ;  P = c, Q = c, R = b, S = c
%@ ;  P = c, Q = c, R = c, S = b
%@ ;  P = c, Q = c, R = c, S = c
%@ ;  false.

% Note how nicely this 0-steps base-case corresponds to the customary
% categorical notation $1_A$ for the identity arrow at object A.
dagr_freecat_nsteps_arrow(G, A,A, 0, [A]) :-
    call(G, _-[A]).

dagr_freecat_nsteps_arrow(G, A,Z, N, [A,B|Xs]) :-
    #N #> 0,
    #Nminus1 #= N - 1,
    length(Xs, Nminus1),
    call(G, A,B), dif(A, B), % admit no trivial steps
    % TODO: Might there generally be principles for immediately rejecting
    %       the pair (B,Z) as incapable of being connected?  How might such
    %       knowledge be encoded, in general?  What if, for *every* pair of
    %       objects (X,Y), we could know an upper bound on the length of the
    %       shortest path connecting them, if such path exists?
    dagr_freecat_nsteps_arrow(G, B,Z, Nminus1, [B|Xs]).

%?- call(three, N-[A]).
%@    N = 0, A = a
%@ ;  N = 1, A = b
%@ ;  N = 1, A = c
%@ ;  false.

% Find all identity arrows:
%?- dagr_freecat_nsteps_arrow(three, X,Y, 0, P).
%@    X = a, Y = a, P = "a"
%@ ;  X = b, Y = b, P = "b"
%@ ;  X = c, Y = c, P = "c"
%@ ;  false.

% Find all 'atomic' arrows:
%?- dagr_freecat_nsteps_arrow(three, X,Y, 1, P).
%@    X = a, Y = b, P = "ab"
%@ ;  X = a, Y = c, P = "ac"
%@ ;  X = b, Y = c, P = "bc"
%@ ;  false.

% Find all arrows composed from 2 atomic arrows:
%?- dagr_freecat_nsteps_arrow(three, X,Y, 2, P).
%@    X = a, Y = c, P = "abc"
%@ ;  false.

% Find all arrows composed from 3 atomic arrows:
%?- dagr_freecat_nsteps_arrow(three, X,Y, 3, P).
%@    false. % correct (none exists)

% Liberalize dagr_freecat_nsteps_arrow/5 to accept Nsteps as a *range*
dagr_freecat_nrange_arrow(G, A,Z, Nrange, Arrow) :-
    N in Nrange, indomain(N),
    dagr_freecat_nsteps_arrow(G, A,Z, N, Arrow).

/*
?- Arrow^Nsteps+\((dagr_freecat_nrange_arrow(three, A,Z, 0..3, Arrow),
                   Arrow=[_|Steps], length(Steps, Nsteps))).
%@    Arrow = "a", Nsteps = 0    % \
%@ ;  Arrow = "b", Nsteps = 0    %  >- Identity arrows
%@ ;  Arrow = "c", Nsteps = 0    % /
%@ ;  Arrow = "ab", Nsteps = 1   % \
%@ ;  Arrow = "ac", Nsteps = 1   %  >- Atomic arrows
%@ ;  Arrow = "bc", Nsteps = 1   % /
%@ ;  Arrow = "abc", Nsteps = 2  % The sole composite arrow in this category.
%@ ;  false.
*/

%?- dagr_freecat_nrange_arrow(three, _,_, 1..10, Arrow).
%@    Arrow = "ab"
%@ ;  Arrow = "ac"
%@ ;  Arrow = "bc"
%@ ;  Arrow = "abc"
%@ ;  false.

% Now we proceed to the 'other end of the spectrum', to the
% generated *preorder* in which by definition all the paths
% A-->B represent *one and the same arrow*.  That is, these
% 'several' paths are [by definition] merely different names
% for THE SAME ARROW.  Thus, in this predicate the _arrow
% has the type of a truth-value.  (Note the connection with
% reification of predicates, warranting further exploration.)

% TODO: What would be very appealing at this point is to implement
%       dagr_freecat_nsteps_t/5 without using (->)/2, and then to
%       exploit the assurances already offered by library(reif).
%       But having thought this thru already for our FLOPS pearl,
%       I believe this will not be possible.  We might however
%       appeal to reasoning similar to that which guarantees the
%       safety of (->)/2 as used in if_/3.  Perhaps this will even
%       turn out to *generalize* that reasoning!

/*
Here are the predicates from library(reif) that use (->)/2 safely:

if_(If_1, Then_0, Else_0) :-
    call(If_1, T),
    (  T == true  -> call(Then_0)
    ;  T == false -> call(Else_0)
    ;  nonvar(T) -> throw(error(type_error(boolean, T), _))
    ;  throw(error(instantiation_error, _))
    ).

=(X, Y, T) :-
    (  X == Y -> T = true
    ;  X \= Y -> T = false
    ;  T = true, X = Y
    ;  T = false, dif(X, Y)
    ).

Why is (->)/2 safe, used thus?
Aha!  As explained by Markus Triska, this is because of strong
entailment linkages between the clauses.  My own interpretation
(all errors mine!) of this is that, X == Y succeeding entails
that X = Y (2nd goal in 3rd clause of the disjunction) would
succeed if reached, and dif(X,Y) (2nd goal in 4th clause of the
disjunction) would fail if reached.  Thus, if X == Y,  we may
'cross out' all the other clauses in the disjunction, giving
warrant to committing via (->)/2.
Alternatively, if X \= Y holds, then we may similarly cross out
the 1st and 3rd clauses of the disjunction; the 4th clause in
this case then merely duplicates what we already know.

I should aim to render arrow-existence from A to B under G,
call this '‚ü∂'(G, A, B, Truth), as self-evidently safe w.r.t.
(->)/2 as the above (=)/3 predicate.

*/

dagr_freecat_nsteps_t(G, A,B, Nsteps, Truth) :-
    call(G, _-[A,B]),
    term_si(A - B), % Enforce the contract with G/1 that it must ground its args.
    dif(A,B),
    (   N in Nsteps, indomain(N), % So [A,B,N] are now all ground.
        dagr_freecat_nsteps_arrow(G, A,B, N, _) -> Truth = true
    ;   Truth = false
    ).

%?- dagr_freecat_nsteps_t(three, a,b, 1, Truth).
%@    Truth = true
%@ ;  false.

%?- dagr_freecat_nsteps_t(three, a,b, 2, Truth).
%@    Truth = false
%@ ;  false.

%?- dagr_freecat_nsteps_t(three, a,c, 2, Truth).
%@    Truth = true
%@ ;  false.

% Because we are working with *strict* preorders, I will use
% the more familiar term 'partial order', abbreviated "po".
% We have a single-witness-suffices situation here, requiring
% careful use of (->)/2.  I would generally like to allow A,B
% to be free variables that collect all solutions.
% Let me begin by actually collecting all the 'separate' paths,
% and then curtailing search for given (A,B) pair.

% Let me not neglect the work already done in dagr_freecat_nsteps_arrow/5!
% Presumably, I can do some kind of brute-force accumulation of a list
% and check for duplication of answers.

% This predicate means that the strict preorder ('partial order')
% generated by G/2 has a non-identity arrow (A-->B) formed from
% a number N of atomic steps (directed edges of graph G/2), with
% N in Nrange.
% Note that *by the design* the enumerative relation G/1 *must*
% yield ground terms, which crucially enables (->)/2 to be used
% for efficiency WITHOUT LOSING SOLUTIONS.
dagr_po_t(G, A,B, Truth) :-
    call(G, _-[A,B]),
    term_si(A - B), % Enforce the contract with G/1 that it must ground its args.
    dif(A,B),
    (   call(G, A, B, Mlub), % Mlub = Minimum length upper bound
        N in 1..Mlub, indomain(N), % ..and N here, we ensure that ..
        AnyArrowExists = dagr_freecat_nsteps(G, A,B, N), % ..this term is ground.
        term_si(AnyArrowExists), % So no solutions (A,B,Truth=true) get lost ..
        AnyArrowExists -> Truth = true % ..by use of impure construct (->)/2 here.
    ;   Truth = false
    ).

% This holds if, in the DAGR defined by G, we can reach B from A
% by *ANY* path of exactly N steps.
dagr_freecat_nsteps(G, A,B, N) :- dagr_freecat_nsteps_arrow(G, A,B, N, _).

%?- dagr_po_t(three, A,B, true).
%@    A = a, B = b
%@ ;  A = a, B = c
%@ ;  A = b, B = c
%@ ;  false.

dagr_po(G, A,B) :- dagr_po_t(G, A,B, true).
 
%?- X^Y+\(Arr = dagr_po(three), call(Arr, X,Y)).
%@    X = a, Y = b
%@ ;  X = a, Y = c
%@ ;  X = b, Y = c
%@ ;  false.

/* ~~~ A fuller demonstration: prove a CLP(Z) relation for monoidal preorder ~~~ */

%% 1. Define evident-$afety relation ‚âº ‚äÇ ùí¨‚úïùí¨ as in Def 2.2:
:- op(900, xfx, =<$).

%?- current_prolog_flag(max_integer, A).
%@    false.

% A fair-enumerating q/1
q(N - [T/N]) :- N in 0..5, indomain(N), 0 #=< #T, T #=< #N, indomain(T).

% And now K-tuples, for K ‚â• 2:
% TODO: Noting how this clause duplicates the general clause of three/1,
%       consider how we might exploit term_expansion/2.
q(N - Vs) :-
    length(Vs, K), K #> 1,
    same_length(Vs, Ns),
    simplex(N, Ns),
    maplist(\Ni^V^q(Ni - [V]), Ns, Vs),
    label([N|Ns]).

% Let's try enumerating ùí¨:
%?- q(N - [Q]).
%@    N = 0, Q = 0/0
%@ ;  N = 1, Q = 0/1
%@ ;  N = 1, Q = 1/1
%@ ;  N = 2, Q = 0/2
%@ ;  N = 2, Q = 1/2
%@ ;  N = 2, Q = 2/2
%@ ;  N = 3, Q = 0/3
%@ ;  N = 3, Q = 1/3
%@ ;  N = 3, Q = 2/3
%@ ;  N = 3, Q = 3/3
%@ ;  N = 4, Q = 0/4
%@ ;  N = 4, Q = 1/4
%@ ;  N = 4, Q = 2/4
%@ ;  N = 4, Q = 3/4
%@ ;  N = 4, Q = 4/4
%@ ;  N = 5, Q = 0/5
%@ ;  N = 5, Q = 1/5
%@ ;  N = 5, Q = 2/5
%@ ;  N = 5, Q = 3/5
%@ ;  N = 5, Q = 4/5
%@ ;  N = 5, Q = 5/5
%@ ;  false.

% Enumerate ùí¨‚úïùí¨:
% TODO: Is this enumeration overly lexicographic?
%       Could I enumerate more compactly and symmetrically?
%       Might simplex/2 be rendered more symmetrical,
%       or would I have to replace it altogether?
%?- q(N - [Q1,Q2]).
%@    N = 0, Q1 = 0/0, Q2 = 0/0
%@ ;  N = 1, Q1 = 0/0, Q2 = 0/1
%@ ;  N = 1, Q1 = 0/0, Q2 = 1/1
%@ ;  N = 2, Q1 = 0/0, Q2 = 0/2
%@ ;  N = 2, Q1 = 0/0, Q2 = 1/2
%@ ;  N = 2, Q1 = 0/0, Q2 = 2/2
%@ ;  N = 3, Q1 = 0/0, Q2 = 0/3
%@ ;  N = 3, Q1 = 0/0, Q2 = 1/3
%@ ;  N = 3, Q1 = 0/0, Q2 = 2/3
%@ ;  N = 3, Q1 = 0/0, Q2 = 3/3
%@ ;  N = 4, Q1 = 0/0, Q2 = 0/4
%@ ;  N = 4, Q1 = 0/0, Q2 = 1/4
%@ ;  N = 4, Q1 = 0/0, Q2 = 2/4
%@ ;  N = 4, Q1 = 0/0, Q2 = 3/4
%@ ;  N = 4, Q1 = 0/0, Q2 = 4/4
%@ ;  N = 5, Q1 = 0/0, Q2 = 0/5
%@ ;  N = 5, Q1 = 0/0, Q2 = 1/5
%@ ;  N = 5, Q1 = 0/0, Q2 = 2/5
%@ ;  N = 5, Q1 = 0/0, Q2 = 3/5
%@ ;  N = 5, Q1 = 0/0, Q2 = 4/5
%@ ;  N = 5, Q1 = 0/0, Q2 = 5/5
%@ ;  N = 1, Q1 = 0/1, Q2 = 0/0
%@ ;  N = 2, Q1 = 0/1, Q2 = 0/1
%@ ;  N = 2, Q1 = 0/1, Q2 = 1/1
%@ ;  N = 3, Q1 = 0/1, Q2 = 0/2
%@ ;  N = 3, Q1 = 0/1, Q2 = 1/2
%@ ;  N = 3, Q1 = 0/1, Q2 = 2/2
%@ ;  N = 4, Q1 = 0/1, Q2 = 0/3
%@ ;  N = 4, Q1 = 0/1, Q2 = 1/3
%@ ;  N = 4, Q1 = 0/1, Q2 = 2/3
%@ ;  N = 4, Q1 = 0/1, Q2 = 3/3
%@ ;  N = 5, Q1 = 0/1, Q2 = 0/4
% ... (big ellipsis)
%@ ;  N = 9, Q1 = 4/5, Q2 = 3/4
%@ ;  N = 9, Q1 = 4/5, Q2 = 4/4
%@ ;  N = 10, Q1 = 4/5, Q2 = 0/5
%@ ;  N = 10, Q1 = 4/5, Q2 = 1/5
%@ ;  N = 10, Q1 = 4/5, Q2 = 2/5
%@ ;  N = 10, Q1 = 4/5, Q2 = 3/5
%@ ;  N = 10, Q1 = 4/5, Q2 = 4/5
%@ ;  N = 10, Q1 = 4/5, Q2 = 5/5
%@ ;  N = 5, Q1 = 5/5, Q2 = 0/0
%@ ;  N = 6, Q1 = 5/5, Q2 = 0/1
%@ ;  N = 6, Q1 = 5/5, Q2 = 1/1
%@ ;  N = 7, Q1 = 5/5, Q2 = 0/2
%@ ;  N = 7, Q1 = 5/5, Q2 = 1/2
%@ ;  N = 7, Q1 = 5/5, Q2 = 2/2
%@ ;  N = 8, Q1 = 5/5, Q2 = 0/3
%@ ;  N = 8, Q1 = 5/5, Q2 = 1/3
%@ ;  N = 8, Q1 = 5/5, Q2 = 2/3
%@ ;  N = 8, Q1 = 5/5, Q2 = 3/3
%@ ;  N = 9, Q1 = 5/5, Q2 = 0/4
%@ ;  N = 9, Q1 = 5/5, Q2 = 1/4
%@ ;  N = 9, Q1 = 5/5, Q2 = 2/4
%@ ;  N = 9, Q1 = 5/5, Q2 = 3/4
%@ ;  N = 9, Q1 = 5/5, Q2 = 4/4
%@ ;  N = 10, Q1 = 5/5, Q2 = 0/5
%@ ;  N = 10, Q1 = 5/5, Q2 = 1/5
%@ ;  N = 10, Q1 = 5/5, Q2 = 2/5
%@ ;  N = 10, Q1 = 5/5, Q2 = 3/5
%@ ;  N = 10, Q1 = 5/5, Q2 = 4/5
%@ ;  N = 10, Q1 = 5/5, Q2 = 5/5
%@ ;  false.

% And now q/2 giving the 'atomic arrows' of a graph generating our preorder:
q(T1/N1, T2/N2) :- % Equation (3)
    N in 0..10, % TODO: Find techniques to increase this to 1_000_000.
    indomain(N),
    simplex(N, [N1,N2]),
    % TODO: Couldn't I just do a single q(N - [T1/T2,T2/N2])?
    %       Or would that substitute search for arithmetic, at great cost?
    (   indomain(N2),
        q(N2 - [T2/N2]),
        #T1 #= T2 + 1, % left half of
        #N1 #= N2 + 1  % Equation (3)
    ;   indomain(N1),
        q(N1 - [T1/N1]),
        #T2 #= T1 + 0, % right half of
        #N2 #= N1 + 1  % Equation (3)
    ),
    label([T1,T2]). % must ground args, per contract enforced by dagr_po_t/4

% Finally, q/3 giving an upper bound on any minimum-length path
% connecting two given objects:
q(T1/N1, T2/N2, L) :-
    q(_-[T1/N1,T2/N2]),
    #U1 #= N1 - T1,
    #U2 #= N2 - T2,
    #L #= max(T1,T2) + max(U1,U2). % TODO: Double-check this fact.

% Does q/2 thus defined ground its 2 terms?  This is the contract!
%?- q(Q, 1/3).
%@    Q = 1/2
%@ ;  Q = 2/4
%@ ;  false.

%?- q(1/3, Q).
%@    Q = 0/2
%@ ;  Q = 1/4
%@ ;  false.

%?- q(Q1, Q2).
%@    Q1 = 1/1, Q2 = 0/0 % left half of Equation (3)
%@ ;  Q1 = 0/0, Q2 = 0/1 % right half
%@ ;  Q1 = 1/2, Q2 = 0/1 % left
%@ ;  Q1 = 2/2, Q2 = 1/1 % left
%@ ;  Q1 = 0/1, Q2 = 0/2 % right
%@ ;  Q1 = 1/1, Q2 = 1/2 % right
%@ ;  Q1 = 1/3, Q2 = 0/2 % left
%@ ;  Q1 = 2/3, Q2 = 1/2 % left
%@ ;  Q1 = 3/3, Q2 = 2/2 % left
%@ ;  Q1 = 0/2, Q2 = 0/3 % right
%@ ;  Q1 = 1/2, Q2 = 1/3 % right
%@ ;  Q1 = 2/2, Q2 = 2/3 % right
%@ ;  Q1 = 1/4, Q2 = 0/3 % left
%@ ;  Q1 = 2/4, Q2 = 1/3 % left
%@ ;  Q1 = 3/4, Q2 = 2/3 % left
%@ ;  Q1 = 4/4, Q2 = 3/3 % left
%@ ;  Q1 = 0/3, Q2 = 0/4 % right
%@ ;  Q1 = 1/3, Q2 = 1/4 % right
%@ ;  Q1 = 2/3, Q2 = 2/4 % right
%@ ;  Q1 = 3/3, Q2 = 3/4 % right
%@ ;  Q1 = 1/5, Q2 = 0/4 % left
%@ ;  Q1 = 2/5, Q2 = 1/4 % left
%@ ;  Q1 = 3/5, Q2 = 2/4 % left
%@ ;  Q1 = 4/5, Q2 = 3/4 % left
%@ ;  Q1 = 5/5, Q2 = 4/4 % left
%@ ;  Q1 = 0/4, Q2 = 0/5 % right
%@ ;  Q1 = 1/4, Q2 = 1/5 % right
%@ ;  Q1 = 2/4, Q2 = 2/5 % right
%@ ;  Q1 = 3/4, Q2 = 3/5 % right
%@ ;  Q1 = 4/4, Q2 = 4/5 % right
%@ ;  false. % Stopped with N in 0..10 bound coded inside q/2

/*
I've just eliminated the L in 0..5 inside dagr_nsteps_po_t/5, at the expense
of restricting the domain of q/1 via N in 0..5 inside its base clause.
And I still run a counter N in 0..10 inside q/2.

But at least my 'generic' graph algorithms are now free of such explicit bounds.

I ought to think how these limits might be factored upward toward the toplevel,
or altogether eliminated.

Perhaps the difficulty amounts to fairly enumerating *jointly* on the levels L
of the domain ùí¨ and on the length N of paths.  With access to a little lemma,
certainly I can link the two.  For example, at any point where I'm restricting
myself to levels 0..L of the domain, there are at most L*(L+1)/2 objects, and
therefore acyclic paths can be no longer than L*(L+1)/2.  This is of course an
extremely weak constraint, but it applies generally.  Perhaps I'll eventually
find an equally reliable, but tighter constraint; but this suffices for now.
*/

% We can implement the *definition* itself:
def2_2(Q1, Q2) :- % Definition 2.2 of Q‚ÇÅ ‚âº Q‚ÇÇ
    dagr_po(q, Q1,Q2).

%?- dagr_po_t(q, A,B, Truth).
%@    A = 0/0, B = 0/1, Truth = true % (*)
%@ ;  A = 0/0, B = 1/1, Truth = false
%@ ;  A = 0/0, B = 0/2, Truth = true
%@ ;  A = 0/0, B = 1/2, Truth = false
%@ ;  A = 0/0, B = 2/2, Truth = false
%@ ;  A = 0/0, B = 0/3, Truth = true % (*)
% ... (big ellipsis)
%@ ;  A = 5/5, B = 3/4, Truth = true % (*)
%@ ;  A = 5/5, B = 4/4, Truth = true % (*)
%@ ;  A = 5/5, B = 0/5, Truth = true % (*)
%@ ;  A = 5/5, B = 1/5, Truth = true % (*)
%@ ;  A = 5/5, B = 2/5, Truth = true % (*)
%@ ;  A = 5/5, B = 3/5, Truth = true % (*)
%@ ;  A = 5/5, B = 4/5, Truth = true % (*)
%@ ;  false.
% Many Truth values (*) are now correctly *true* after freeing nsteps.

%?- q(0 - [A,B]).
%@    A = 0/0, B = 0/0
%@ ;  false.

%?- q(1 - [A,B]).
%@    A = 0/0, B = 0/1
%@ ;  A = 0/0, B = 1/1
%@ ;  A = 0/1, B = 0/0
%@ ;  A = 1/1, B = 0/0
%@ ;  false.

%?- q(2 - [A,B]).
%@    A = 0/0, B = 0/2
%@ ;  A = 0/0, B = 1/2
%@ ;  A = 0/0, B = 2/2
%@ ;  A = 0/1, B = 0/1
%@ ;  A = 0/1, B = 1/1
%@ ;  A = 1/1, B = 0/1
%@ ;  A = 1/1, B = 1/1
%@ ;  A = 0/2, B = 0/0
%@ ;  A = 1/2, B = 0/0
%@ ;  A = 2/2, B = 0/0
%@ ;  false.

%?- def2_2(Q1, Q2).
%@    Q1 = 0/0, Q2 = 0/1
%@ ;  Q1 = 0/0, Q2 = 0/2
%@ ;  Q1 = 0/0, Q2 = 0/3
%@ ;  Q1 = 0/0, Q2 = 0/4
%@ ;  Q1 = 0/0, Q2 = 0/5
%@ ;  Q1 = 0/1, Q2 = 0/2
%@ ;  Q1 = 0/1, Q2 = 0/3
%@ ;  Q1 = 0/1, Q2 = 0/4
%@ ;  Q1 = 0/1, Q2 = 0/5
%@ ;  Q1 = 1/1, Q2 = 0/0
%@ ;  Q1 = 1/1, Q2 = 0/1
%@ ;  Q1 = 1/1, Q2 = 0/2
%@ ;  Q1 = 1/1, Q2 = 1/2
%@ ;  Q1 = 1/1, Q2 = 0/3
%@ ;  Q1 = 1/1, Q2 = 1/3
%@ ;  Q1 = 1/1, Q2 = 0/4
%@ ;  Q1 = 1/1, Q2 = 1/4
%@ ;  Q1 = 1/1, Q2 = 0/5
%@ ;  Q1 = 1/1, Q2 = 1/5
%@ ;  Q1 = 0/2, Q2 = 0/3
%@ ;  Q1 = 0/2, Q2 = 0/4
%@ ;  Q1 = 0/2, Q2 = 0/5
%@ ;  Q1 = 1/2, Q2 = 0/1
%@ ;  Q1 = 1/2, Q2 = 0/2
%@ ;  Q1 = 1/2, Q2 = 0/3
%@ ;  Q1 = 1/2, Q2 = 1/3
%@ ;  Q1 = 1/2, Q2 = 0/4
%@ ;  Q1 = 1/2, Q2 = 1/4
%@ ;  Q1 = 1/2, Q2 = 0/5
%@ ;  Q1 = 1/2, Q2 = 1/5
%@ ;  Q1 = 2/2, Q2 = 0/0
%@ ;  Q1 = 2/2, Q2 = 0/1
%@ ;  Q1 = 2/2, Q2 = 1/1
%@ ;  Q1 = 2/2, Q2 = 0/2
%@ ;  Q1 = 2/2, Q2 = 1/2
%@ ;  Q1 = 2/2, Q2 = 0/3
%@ ;  Q1 = 2/2, Q2 = 1/3
%@ ;  Q1 = 2/2, Q2 = 2/3
%@ ;  Q1 = 2/2, Q2 = 0/4
%@ ;  Q1 = 2/2, Q2 = 1/4
%@ ;  ... .

%?- q(1/1, Q), q(Q, 0/1).
%@    Q = 0/0
%@ ;  Q = 1/2 % Interesting!
%@ ;  false.

%?- dagr_freecat_nsteps_arrow(q, 1/1, 0/1, 2, P).
%@    P = [1/1,0/0,0/1]
%@ ;  P = [1/1,1/2,0/1]
%@ ;  false.

/*
So this code is capable of revealing a few little surprises!
Note that the above shows that

        1/1 ‚âºL 0/0 ‚âºR 0/1
  and
        1/1 ‚âºR 1/2 ‚âºL 0/1

are *both* proofs that 1/1 ‚âº 0/1.  [I have used suffixes L and R
to indicate which half of Equation (3) is used in each instance.]
*/

%?- N in 1..4, indomain(N), dagr_freecat_nsteps_arrow(q, 1/1, 0/1, N, A).
%@    N = 2, A = [1/1,0/0,0/1]
%@ ;  N = 2, A = [1/1,1/2,0/1]
%@ ;  false.

%?- dagr_po_t(q, 1/1, 0/1, Truth).
%@    Truth = true
%@ ;  false.

%?- N in 0..3, q(N - [A,B]).
%@    N = 0, A = 0/0, B = 0/0
%@ ;  N = 1, A = 0/0, B = 0/1
%@ ;  N = 1, A = 0/0, B = 1/1
%@ ;  N = 2, A = 0/0, B = 0/2
%@ ;  N = 2, A = 0/0, B = 1/2
%@ ;  N = 2, A = 0/0, B = 2/2
%@ ;  N = 3, A = 0/0, B = 0/3
%@ ;  N = 3, A = 0/0, B = 1/3
%@ ;  N = 3, A = 0/0, B = 2/3
%@ ;  N = 3, A = 0/0, B = 3/3
%@ ;  N = 1, A = 0/1, B = 0/0
%@ ;  N = 1, A = 1/1, B = 0/0
%@ ;  N = 2, A = 0/1, B = 0/1
%@ ;  N = 2, A = 0/1, B = 1/1
%@ ;  N = 2, A = 1/1, B = 0/1
%@ ;  N = 2, A = 1/1, B = 1/1
%@ ;  N = 3, A = 0/1, B = 0/2
%@ ;  N = 3, A = 0/1, B = 1/2
%@ ;  N = 3, A = 0/1, B = 2/2
%@ ;  N = 3, A = 1/1, B = 0/2
%@ ;  N = 3, A = 1/1, B = 1/2
%@ ;  N = 3, A = 1/1, B = 2/2
%@ ;  N = 2, A = 0/2, B = 0/0
%@ ;  N = 2, A = 1/2, B = 0/0
%@ ;  N = 2, A = 2/2, B = 0/0
%@ ;  N = 3, A = 0/2, B = 0/1
%@ ;  N = 3, A = 0/2, B = 1/1
%@ ;  N = 3, A = 1/2, B = 0/1
%@ ;  N = 3, A = 1/2, B = 1/1
%@ ;  N = 3, A = 2/2, B = 0/1
%@ ;  N = 3, A = 2/2, B = 1/1
%@ ;  N = 3, A = 0/3, B = 0/0
%@ ;  N = 3, A = 1/3, B = 0/0
%@ ;  N = 3, A = 2/3, B = 0/0
%@ ;  N = 3, A = 3/3, B = 0/0
%@ ;  false.

%?- dagr_freecat_nsteps_arrow(q, 1/1,0/1, N, A).
%@    A = [1/1,0/0,0/1], N = 2
%@ ;  A = [1/1,1/2,0/1], N = 2
%@ ;     error('$interrupt_thrown',repl/0). % likely N ‚Üí ‚àû

%?- dagr_freecat_nsteps_arrow(q, 1/1,0/1, 3, A).
%@    false.

%?- dagr_freecat_nsteps_arrow(q, 1/1,0/1, 4, A).
%@    false.

%?- dagr_freecat_nsteps_arrow(q, 1/1,0/1, 10, A).
%@    false.

%?- time(dagr_freecat_nsteps_arrow(q, 1/1,0/1, 20, A)).
%@    % CPU time: 0.180s, 925_402 inferences
%@    false.

%?- dagr_freecat_nsteps_arrow(q, 1/1,0/1, 2, [1/1,1/2,0/1]).
%@    true
%@ ;  false.

%?- dagr_freecat_nsteps_arrow(q, 1/1,0/1, N, A).
%@    A = [1/1,0/0,0/1], N = 2
%@ ;  A = [1/1,1/2,0/1], N = 2
%@ ;     error('$interrupt_thrown',repl/0).

%?- N in 1..4, dagr_freecat_nsteps_arrow(q, 1/1,0/1, N, A).
%@    N = 2, A = [1/1,0/0,0/1]
%@ ;  N = 2, A = [1/1,1/2,0/1]
%@ ;     error('$interrupt_thrown',repl/0).

%?- N in 1..4, indomain(N), dagr_freecat_nsteps_arrow(q, 1/1,0/1, N, A).
%@    N = 2, A = [1/1,0/0,0/1]
%@ ;  N = 2, A = [1/1,1/2,0/1]
%@ ;  false. % Aha!  So N simply grows without bound unless explicitly forbidden.

%?- dagr_freecat_nsteps_arrow(q, Q,0/1, 1, A).
%@    Q = 0/0, A = [0/0,0/1]
%@ ;  Q = 1/2, A = [1/2,0/1]
%@ ;  false.

%?- q(1/1, 0/1).
%@    false. % Correct -- arrow 1/1 ‚âº 0/1 is *not* atomic

%?- q(1/1, Q), q(Q, 0/1).
%@    Q = 0/0
%@ ;  Q = 1/2
%@ ;  false.


%% Commented below is the implementation of ‚âº on ùí¨^D.  Before daring
%% to tackle the proof of Fact 2.13 I had better prove Fact 2.4!

% We define (=<$)/2 to be the RHS of Fact 2.4
=<$(T1/N1, T2/N2) :- #T1 #>= #T2 + max(0, #N1 - #N2).

% Our task now is to show that this relation coincides with dagr_po(q)/2.
%?- dagr_po(q, Q1, Q2).
%@    Q1 = 0/0, Q2 = 0/1
%@ ;  Q1 = 0/0, Q2 = 0/2
%@ ;  Q1 = 0/0, Q2 = 0/3
%@ ;  Q1 = 0/0, Q2 = 0/4
%@ ;  Q1 = 0/0, Q2 = 0/5
%@ ;  Q1 = 0/1, Q2 = 0/2
%@ ;  Q1 = 0/1, Q2 = 0/3
%@ ;  Q1 = 0/1, Q2 = 0/4
%@ ;  ... .

dagr_po_finds_nonexistent_arrow(Q1, Q2) :-
    dagr_po(q, Q1, Q2),
    term_si(Q1 - Q2),
    \(Q2 =<$ Q1).

%?- time(dagr_po_finds_nonexistent_arrow(Q1, Q2)).
%@    % CPU time: 59.932s, 321_968_608 inferences
%@    false.

dagr_po_denies_true_arrow(Q1, Q2) :-
    q(_ - [Q1,Q2]), % NB: this enumerates pairs (Q1,Q2) up thru level 5
    Q1 =<$ Q2,
    term_si(Q1 - Q2),
    dagr_po_t(q, Q1, Q2, false).

%?- time(dagr_po_denies_true_arrow(Q1, Q2)).
%@    % CPU time: 26.009s, 139_612_447 inferences
%@    false.

/*
=<$(Q1s, Q2s) :-
    qs_ts_us(Q1s, T1s, U1s),
    qs_ts_us(Q2s, T2s, U2s),
    intlist_partsums(T1s, ST1s), intlist_partsums(U1s, SU1s),
    intlist_partsums(T2s, ST2s), intlist_partsums(U2s, SU2s),
    maplist(#>=, ST1s, ST2s),
    maplist(#=<, SU1s, SU2s).

%% Allow the notational convenience of a 'flippable' preorder symbol:
:- op(900, xfx, $>=).
$>=(Q1, Q2) :- =<$(Q2, Q1).

%% Utility predicates used above:

qs_ts_us(Qs, Ts, Us) :-
    maplist(\Q^T^U^(Q = T/N, #U #= N - T), Qs, Ts, Us).

intlist_partsums([X|Xs], [X|Ss]) :-
    intlist_partsums_acc(Xs, Ss, X).

intlist_partsums_acc([], [], _).
intlist_partsums_acc([X|Xs], [S|Ss], A) :-
    #S #= #X + #A,
    intlist_partsums_acc(Xs, Ss, S).

%?- [1/3, 1/2] =<$ [0/4, 0/1].
%@    true.

%?- [1/6,1/6] =<$ [0/6,2/6].
%@    true.

%?- [1/6,1/6] =<$ [0/6,2/5].
%@    false.

%?- [1/6,1/6] =<$ [0/6,2/7].
%@    true.

%?- [0/6,2/6] $>= [1/6,1/6].
%@    true.

% 2. Note that a recursive implementation is possible, which might
%    conceivably fail earlier & faster in big searches.
qs_sum1([T1/N1, T2/N2 | Qs], [T12/N12 | Qs]) :-
    #T12 #= #T1 + #T2,
    #N12 #= #N1 + #N2.

lesaf([Q1|Q1s], [Q2|Q2s]) :-
    Q1 =<$ Q2,
    lesaf_([Q1|Q1s], [Q2|Q2s]).
lesaf_([_], [_]). % nothing to do!
lesaf_([Q1,Q1b|Q1s], [Q2,Q2b|Q2s]) :-
    qs_sum1([Q1,Q1b|Q1s], Q1s_),
    qs_sum1([Q2,Q2b|Q2s], Q2s_),
    lesaf_(Q1s_, Q2s_).

%?- lesaf_([], []).
%@    false.

%?- [1/6] =<$ [0/6].
%@    true.

%?- lesaf_([1/6,1/6], [0/6,2/6]).
%@    true
%@ ;  false.

*/
